import numpy as np

from opacity import get_opacity
from constants import * # in cgs units
from scipy.integrate import solve_ivp

# Chosen metallicity
X = 0.7
Y = 0.28
Z = 0.02

# Chosen mass
M = 1.1 * Ms

def get_mu(X=X, Y=Y):
    """
    Get mean molecular weight assuming fully ionized gas

    Parameters
    ----------
    X : float
        Hydrogen fraction
    Y : float
        Helium fraction

    Returns
    -------
    float
        mean molecular weight
    """

    return 4/(6*X + Y + 2)

mu = get_mu()

# Get density rho from pressure, temperature, and composition
def get_density(P, T):
    """
    Get density given pressure and temperature (and metallicity)

    Parameters
    ----------
    P : float
        Pressure in g cm^-1 s^-2
    T : float
        Temperature in K

    Returns
    -------
    float
        density in g cm^-3
    """

    P_rad = (a * T**4)/3

    rho = (P - P_rad) * (mu * mp)/(k * T)

    return rho

def get_energy(T, rho):
    """
    Calculate total energy generated by nuclear reactions 

    Parameters
    ----------
    T : float
        Temperature in K
    rho : float
        Density in g cm^-3

    Returns
    -------
    float
        Total energy generated in g cm^2 s^-2 (erg)
    """

    # Put temp in useful variables
    T7 = T/1e7
    T9 = T/1e9

    EkT = 5.92e-3 * np.sqrt(rho/T7**3)
    # Weak screening factor
    f11 = np.exp(EkT)
    # g factors
    g11 = 1 + (3.82*T9) + (1.51*T9**2) + (0.144*T9**3) - (0.0114*T9**4)
    g141 = 1 - 2*T9 + 3.41*T9**2 - 2.43*T9**3

    psi = np.where(T7 < 1, 1.0, np.where(T7 > 3, 1.4, 0.9 + 0.2 * T7))

    # CNO metal fraction taken from opacity table
    X_cno = Z * (0.313563+0.124832+0.227156)

    # pp chain energy
    pp  = 2.57e4 * psi * f11 * g11 * rho * X**2 * T9**(-2/3) * np.exp(-3.381/T9**(1/3))
    # cno cycle energy
    cno = 8.24e25 * g141 * X_cno * X * rho * T9**(-2/3) * np.exp(-15.231*T9**(-1/3) - (T9/0.8)**2)

    return pp + cno
    

def grad_rad(P, T, kappa, l, m):
    return (3 / (16 * np.pi * a * c * G)) * ( kappa * l * P / (m * T**4))


def get_grad(P, T, kappa, l, m):
    """
    Calculate radiative gradient and determine whether the radiative or adiabatic regime is appropriate

    Parameters
    ----------
    P : float
        Pressure in g cm^-1 s^-2
    T : float
        Temperature in K
    kappa : float
        Opacity in cm^2 g^-1
    l : float
        Luminosity in g cm^2 s^-3 (erg/s)
    m : float
        Mass in g

    Returns
    -------
    float
        Appropriate gradient value
    """
    grad_ad = 0.4
    grad_rad = (3 / (16 * np.pi * a * c * G)) * ( kappa * l * P / (m * T**4))

    # Proper regime is whichever gradient is lower
    return np.min([grad_ad, grad_rad])

def load1(P_c, T_c):
    """
    Set up inner boundary conditions given central pressure and temperature

    Parameters
    ----------
    P_c : float
        Central pressure in g cm^-1 s^-2
    T_c : _type_
        Central temperature in K

    Returns
    -------
    list
        Luminosity, pressure, radius, and temperature at the inner boundary
    """

    # Get central density
    rho_c = get_density(P_c, T_c)
    # Get central energy generation
    epsilon_c = get_energy(T_c, rho_c)

    # m starts next to 0 for numerical reasons
    m = 1e-6

    l = epsilon_c * m
    r = (3 * m / (4 * np.pi * rho_c))**(1/3)
    P = P_c - (3 * G / (8 * np.pi)) * (4 * np.pi * rho_c / 3)**(4/3) * m**(2/3)

    # Check if radiative or convective
    kappa = get_opacity(T_c, rho_c)
    grad = get_grad(P_c, T_c, kappa, l, m)

    if grad == 0.4: # Convective case
        rhs = -(np.pi/6)**(1/3) * G * (grad * rho_c**(4/3) / P_c) * m**(2/3)
        T = np.exp(rhs + np.log(T_c))
    else: # Radiative case
        rhs = -1/(2*a*c) * (3/(4*np.pi))**(2/3) * kappa * epsilon_c * rho_c**(4/3) * m**(2/3)
        T = (rhs + T_c**4)**(1/4)

    return [l, P, r, T]

def load2(L, R, M):
    """
    Set up outer boundary conditions given total luminosity and radius

    Parameters
    ----------
    L : float
        Total luminosity in g cm^2 s^-3 (erg/s)
    R : float
        Total radius in cm
    M : float
        Total mass in g

    Returns
    -------
    list
        Luminosity, pressure, radius, and temperature at the outer boundary
    """
    l = L
    r = R
    T = (L/(4 * np.pi * R**2 * sb))**(1/4)
    P_rad = (a * T**4)/3

    def eddington_grey(tau, P):
        """
        Function representing dP/dtau to get pressure for Eddington Grey atmosphere
        """

        P = P[0]

        T_tau = ((3 / 4) * (L / (4 * np.pi * R**2 * sb)) * (tau + 2/3))**(1/4)
        rho = get_density(P, T_tau)
        kappa = get_opacity(T_tau, rho)

        dPdtau = G * M / R**2 / kappa

        return [dPdtau]
    
    # Solve for Eddington Grey, start with P=P_rad at tau=0
    sol_eg = solve_ivp(
        eddington_grey,
        [0, 2/3],
        [P_rad],
        dense_output = True
    )

    P = sol_eg.y[0][-1]
    
    return [l, P, r, T]

def derivs(m, vals):
    """
    Calculated derivatives for each ODE using passed m and [l, P, r, T] values

    Parameters
    ----------
    m : float
        Mass in g
    vals : list
        List containing l (in erg/s), P (in g cm^-1 s^-2), r (in cm), and T (in K)

    Returns
    -------
    list
        List of derivatives calculated using values provided
    """
    l, P, r, T = vals

    rho = get_density(P, T)
    kappa = get_opacity(T, rho)
    grad = get_grad(P, T, kappa, l, m)

    dldm = get_energy(T, rho)
    dPdm = -G * m / (4 * np.pi * r**4)
    drdm = 1/(4 * np.pi * r**2 * rho)
    dTdm = -G * m * T * grad / (4 * np.pi * r**4 * P)

    return [dldm, dPdm, drdm, dTdm]